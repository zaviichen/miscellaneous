// Generated by ProtoGen, Version=2.4.1.521, Culture=neutral, PublicKeyToken=55f7125234beb589.  DO NOT EDIT!
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.ProtocolBuffers;
using pbc = global::Google.ProtocolBuffers.Collections;
using pbd = global::Google.ProtocolBuffers.Descriptors;
using scg = global::System.Collections.Generic;
namespace Tdx {
  
  namespace Proto {
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Order {
    
      #region Extension registration
      public static void RegisterAllExtensions(pb::ExtensionRegistry registry) {
      }
      #endregion
      #region Static variables
      internal static pbd::MessageDescriptor internal__static_common_Order__Descriptor;
      internal static pb::FieldAccess.FieldAccessorTable<global::Tdx.Order, global::Tdx.Order.Builder> internal__static_common_Order__FieldAccessorTable;
      #endregion
      #region Descriptor
      public static pbd::FileDescriptor Descriptor {
        get { return descriptor; }
      }
      private static pbd::FileDescriptor descriptor;
      
      static Order() {
        byte[] descriptorData = global::System.Convert.FromBase64String(
            "CgtvcmRlci5wcm90bxIGY29tbW9uIvYCCgVPcmRlchIKCgJpZBgBIAIoAxIO" + 
            "CgZicm9rZXIYAiABKAkSEAoIZXhjaGFuZ2UYAyABKAkSEAoIaW52ZXN0b3IY" + 
            "BCABKAkSEgoKaW5zdHJ1bWVudBgFIAEoCRITCgtsaW1pdF9wcmljZRgGIAEo" + 
            "ARISCgpzdG9wX3ByaWNlGAcgASgBEg4KBnZvbHVtZRgIIAEoAxIqCglkaXJl" + 
            "Y3Rpb24YCSABKA4yFy5jb21tb24uT3JkZXIuRGlyZWN0aW9uEhAKCGRhdGV0" + 
            "aW1lGAogASgDEiAKBHR5cGUYCyABKA4yEi5jb21tb24uT3JkZXIuVHlwZRIQ" + 
            "CghjdXJyZW5jeRgMIAEoCRIOCgZleHBpcnkYDSABKAkSFQoNc2VjdXJpdHlf" + 
            "dHlwZRgOIAEoCSIeCglEaXJlY3Rpb24SBwoDQlVZEAESCAoEU0VMTBACIicK" + 
            "BFR5cGUSCgoGTUFSS0VUEAESCQoFTElNSVQQAhIICgRTVE9QEANCGwoMY29t" + 
            "bW9uLnByb3RvQgtPcmRlclByb3Rvcw==");
        pbd::FileDescriptor.InternalDescriptorAssigner assigner = delegate(pbd::FileDescriptor root) {
          descriptor = root;
          internal__static_common_Order__Descriptor = Descriptor.MessageTypes[0];
          internal__static_common_Order__FieldAccessorTable = 
              new pb::FieldAccess.FieldAccessorTable<global::Tdx.Order, global::Tdx.Order.Builder>(internal__static_common_Order__Descriptor,
                  new string[] { "Id", "Broker", "Exchange", "Investor", "Instrument", "LimitPrice", "StopPrice", "Volume", "Direction", "Datetime", "Type", "Currency", "Expiry", "SecurityType", });
          return null;
        };
        pbd::FileDescriptor.InternalBuildGeneratedFileFrom(descriptorData,
            new pbd::FileDescriptor[] {
            }, assigner);
      }
      #endregion
      
    }
  }
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class Order : pb::GeneratedMessage<Order, Order.Builder> {
    private Order() { }
    private static readonly Order defaultInstance = new Order().MakeReadOnly();
    private static readonly string[] _orderFieldNames = new string[] { "broker", "currency", "datetime", "direction", "exchange", "expiry", "id", "instrument", "investor", "limit_price", "security_type", "stop_price", "type", "volume" };
    private static readonly uint[] _orderFieldTags = new uint[] { 18, 98, 80, 72, 26, 106, 8, 42, 34, 49, 114, 57, 88, 64 };
    public static Order DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override Order DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override Order ThisMessage {
      get { return this; }
    }
    
    public static pbd::MessageDescriptor Descriptor {
      get { return global::Tdx.Proto.Order.internal__static_common_Order__Descriptor; }
    }
    
    protected override pb::FieldAccess.FieldAccessorTable<Order, Order.Builder> InternalFieldAccessors {
      get { return global::Tdx.Proto.Order.internal__static_common_Order__FieldAccessorTable; }
    }
    
    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      public enum Direction {
        BUY = 1,
        SELL = 2,
      }
      
      public enum Type {
        MARKET = 1,
        LIMIT = 2,
        STOP = 3,
      }
      
    }
    #endregion
    
    public const int IdFieldNumber = 1;
    private bool hasId;
    private long id_;
    public bool HasId {
      get { return hasId; }
    }
    public long Id {
      get { return id_; }
    }
    
    public const int BrokerFieldNumber = 2;
    private bool hasBroker;
    private string broker_ = "";
    public bool HasBroker {
      get { return hasBroker; }
    }
    public string Broker {
      get { return broker_; }
    }
    
    public const int ExchangeFieldNumber = 3;
    private bool hasExchange;
    private string exchange_ = "";
    public bool HasExchange {
      get { return hasExchange; }
    }
    public string Exchange {
      get { return exchange_; }
    }
    
    public const int InvestorFieldNumber = 4;
    private bool hasInvestor;
    private string investor_ = "";
    public bool HasInvestor {
      get { return hasInvestor; }
    }
    public string Investor {
      get { return investor_; }
    }
    
    public const int InstrumentFieldNumber = 5;
    private bool hasInstrument;
    private string instrument_ = "";
    public bool HasInstrument {
      get { return hasInstrument; }
    }
    public string Instrument {
      get { return instrument_; }
    }
    
    public const int LimitPriceFieldNumber = 6;
    private bool hasLimitPrice;
    private double limitPrice_;
    public bool HasLimitPrice {
      get { return hasLimitPrice; }
    }
    public double LimitPrice {
      get { return limitPrice_; }
    }
    
    public const int StopPriceFieldNumber = 7;
    private bool hasStopPrice;
    private double stopPrice_;
    public bool HasStopPrice {
      get { return hasStopPrice; }
    }
    public double StopPrice {
      get { return stopPrice_; }
    }
    
    public const int VolumeFieldNumber = 8;
    private bool hasVolume;
    private long volume_;
    public bool HasVolume {
      get { return hasVolume; }
    }
    public long Volume {
      get { return volume_; }
    }
    
    public const int DirectionFieldNumber = 9;
    private bool hasDirection;
    private global::Tdx.Order.Types.Direction direction_ = global::Tdx.Order.Types.Direction.BUY;
    public bool HasDirection {
      get { return hasDirection; }
    }
    public global::Tdx.Order.Types.Direction Direction {
      get { return direction_; }
    }
    
    public const int DatetimeFieldNumber = 10;
    private bool hasDatetime;
    private long datetime_;
    public bool HasDatetime {
      get { return hasDatetime; }
    }
    public long Datetime {
      get { return datetime_; }
    }
    
    public const int TypeFieldNumber = 11;
    private bool hasType;
    private global::Tdx.Order.Types.Type type_ = global::Tdx.Order.Types.Type.MARKET;
    public bool HasType {
      get { return hasType; }
    }
    public global::Tdx.Order.Types.Type Type {
      get { return type_; }
    }
    
    public const int CurrencyFieldNumber = 12;
    private bool hasCurrency;
    private string currency_ = "";
    public bool HasCurrency {
      get { return hasCurrency; }
    }
    public string Currency {
      get { return currency_; }
    }
    
    public const int ExpiryFieldNumber = 13;
    private bool hasExpiry;
    private string expiry_ = "";
    public bool HasExpiry {
      get { return hasExpiry; }
    }
    public string Expiry {
      get { return expiry_; }
    }
    
    public const int SecurityTypeFieldNumber = 14;
    private bool hasSecurityType;
    private string securityType_ = "";
    public bool HasSecurityType {
      get { return hasSecurityType; }
    }
    public string SecurityType {
      get { return securityType_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasId) return false;
        return true;
      }
    }
    
    public override void WriteTo(pb::ICodedOutputStream output) {
      int size = SerializedSize;
      string[] field_names = _orderFieldNames;
      if (hasId) {
        output.WriteInt64(1, field_names[6], Id);
      }
      if (hasBroker) {
        output.WriteString(2, field_names[0], Broker);
      }
      if (hasExchange) {
        output.WriteString(3, field_names[4], Exchange);
      }
      if (hasInvestor) {
        output.WriteString(4, field_names[8], Investor);
      }
      if (hasInstrument) {
        output.WriteString(5, field_names[7], Instrument);
      }
      if (hasLimitPrice) {
        output.WriteDouble(6, field_names[9], LimitPrice);
      }
      if (hasStopPrice) {
        output.WriteDouble(7, field_names[11], StopPrice);
      }
      if (hasVolume) {
        output.WriteInt64(8, field_names[13], Volume);
      }
      if (hasDirection) {
        output.WriteEnum(9, field_names[3], (int) Direction, Direction);
      }
      if (hasDatetime) {
        output.WriteInt64(10, field_names[2], Datetime);
      }
      if (hasType) {
        output.WriteEnum(11, field_names[12], (int) Type, Type);
      }
      if (hasCurrency) {
        output.WriteString(12, field_names[1], Currency);
      }
      if (hasExpiry) {
        output.WriteString(13, field_names[5], Expiry);
      }
      if (hasSecurityType) {
        output.WriteString(14, field_names[10], SecurityType);
      }
      UnknownFields.WriteTo(output);
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        
        size = 0;
        if (hasId) {
          size += pb::CodedOutputStream.ComputeInt64Size(1, Id);
        }
        if (hasBroker) {
          size += pb::CodedOutputStream.ComputeStringSize(2, Broker);
        }
        if (hasExchange) {
          size += pb::CodedOutputStream.ComputeStringSize(3, Exchange);
        }
        if (hasInvestor) {
          size += pb::CodedOutputStream.ComputeStringSize(4, Investor);
        }
        if (hasInstrument) {
          size += pb::CodedOutputStream.ComputeStringSize(5, Instrument);
        }
        if (hasLimitPrice) {
          size += pb::CodedOutputStream.ComputeDoubleSize(6, LimitPrice);
        }
        if (hasStopPrice) {
          size += pb::CodedOutputStream.ComputeDoubleSize(7, StopPrice);
        }
        if (hasVolume) {
          size += pb::CodedOutputStream.ComputeInt64Size(8, Volume);
        }
        if (hasDirection) {
          size += pb::CodedOutputStream.ComputeEnumSize(9, (int) Direction);
        }
        if (hasDatetime) {
          size += pb::CodedOutputStream.ComputeInt64Size(10, Datetime);
        }
        if (hasType) {
          size += pb::CodedOutputStream.ComputeEnumSize(11, (int) Type);
        }
        if (hasCurrency) {
          size += pb::CodedOutputStream.ComputeStringSize(12, Currency);
        }
        if (hasExpiry) {
          size += pb::CodedOutputStream.ComputeStringSize(13, Expiry);
        }
        if (hasSecurityType) {
          size += pb::CodedOutputStream.ComputeStringSize(14, SecurityType);
        }
        size += UnknownFields.SerializedSize;
        memoizedSerializedSize = size;
        return size;
      }
    }
    
    public static Order ParseFrom(pb::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Order ParseFrom(pb::ByteString data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Order ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static Order ParseFrom(byte[] data, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static Order ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Order ParseFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static Order ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static Order ParseDelimitedFrom(global::System.IO.Stream input, pb::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static Order ParseFrom(pb::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static Order ParseFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private Order MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(Order prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public sealed partial class Builder : pb::GeneratedBuilder<Order, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(Order cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private Order result;
      
      private Order PrepareBuilder() {
        if (resultIsReadOnly) {
          Order original = result;
          result = new Order();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override Order MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override pbd::MessageDescriptor DescriptorForType {
        get { return global::Tdx.Order.Descriptor; }
      }
      
      public override Order DefaultInstanceForType {
        get { return global::Tdx.Order.DefaultInstance; }
      }
      
      public override Order BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(pb::IMessage other) {
        if (other is Order) {
          return MergeFrom((Order) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(Order other) {
        if (other == global::Tdx.Order.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasId) {
          Id = other.Id;
        }
        if (other.HasBroker) {
          Broker = other.Broker;
        }
        if (other.HasExchange) {
          Exchange = other.Exchange;
        }
        if (other.HasInvestor) {
          Investor = other.Investor;
        }
        if (other.HasInstrument) {
          Instrument = other.Instrument;
        }
        if (other.HasLimitPrice) {
          LimitPrice = other.LimitPrice;
        }
        if (other.HasStopPrice) {
          StopPrice = other.StopPrice;
        }
        if (other.HasVolume) {
          Volume = other.Volume;
        }
        if (other.HasDirection) {
          Direction = other.Direction;
        }
        if (other.HasDatetime) {
          Datetime = other.Datetime;
        }
        if (other.HasType) {
          Type = other.Type;
        }
        if (other.HasCurrency) {
          Currency = other.Currency;
        }
        if (other.HasExpiry) {
          Expiry = other.Expiry;
        }
        if (other.HasSecurityType) {
          SecurityType = other.SecurityType;
        }
        this.MergeUnknownFields(other.UnknownFields);
        return this;
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input) {
        return MergeFrom(input, pb::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(pb::ICodedInputStream input, pb::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        pb::UnknownFieldSet.Builder unknownFields = null;
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_orderFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _orderFieldTags[field_ordinal];
            else {
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw pb::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (pb::WireFormat.IsEndGroupTag(tag)) {
                if (unknownFields != null) {
                  this.UnknownFields = unknownFields.Build();
                }
                return this;
              }
              if (unknownFields == null) {
                unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
              }
              ParseUnknownField(input, unknownFields, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              result.hasId = input.ReadInt64(ref result.id_);
              break;
            }
            case 18: {
              result.hasBroker = input.ReadString(ref result.broker_);
              break;
            }
            case 26: {
              result.hasExchange = input.ReadString(ref result.exchange_);
              break;
            }
            case 34: {
              result.hasInvestor = input.ReadString(ref result.investor_);
              break;
            }
            case 42: {
              result.hasInstrument = input.ReadString(ref result.instrument_);
              break;
            }
            case 49: {
              result.hasLimitPrice = input.ReadDouble(ref result.limitPrice_);
              break;
            }
            case 57: {
              result.hasStopPrice = input.ReadDouble(ref result.stopPrice_);
              break;
            }
            case 64: {
              result.hasVolume = input.ReadInt64(ref result.volume_);
              break;
            }
            case 72: {
              object unknown;
              if(input.ReadEnum(ref result.direction_, out unknown)) {
                result.hasDirection = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(9, (ulong)(int)unknown);
              }
              break;
            }
            case 80: {
              result.hasDatetime = input.ReadInt64(ref result.datetime_);
              break;
            }
            case 88: {
              object unknown;
              if(input.ReadEnum(ref result.type_, out unknown)) {
                result.hasType = true;
              } else if(unknown is int) {
                if (unknownFields == null) {
                  unknownFields = pb::UnknownFieldSet.CreateBuilder(this.UnknownFields);
                }
                unknownFields.MergeVarintField(11, (ulong)(int)unknown);
              }
              break;
            }
            case 98: {
              result.hasCurrency = input.ReadString(ref result.currency_);
              break;
            }
            case 106: {
              result.hasExpiry = input.ReadString(ref result.expiry_);
              break;
            }
            case 114: {
              result.hasSecurityType = input.ReadString(ref result.securityType_);
              break;
            }
          }
        }
        
        if (unknownFields != null) {
          this.UnknownFields = unknownFields.Build();
        }
        return this;
      }
      
      
      public bool HasId {
        get { return result.hasId; }
      }
      public long Id {
        get { return result.Id; }
        set { SetId(value); }
      }
      public Builder SetId(long value) {
        PrepareBuilder();
        result.hasId = true;
        result.id_ = value;
        return this;
      }
      public Builder ClearId() {
        PrepareBuilder();
        result.hasId = false;
        result.id_ = 0L;
        return this;
      }
      
      public bool HasBroker {
        get { return result.hasBroker; }
      }
      public string Broker {
        get { return result.Broker; }
        set { SetBroker(value); }
      }
      public Builder SetBroker(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasBroker = true;
        result.broker_ = value;
        return this;
      }
      public Builder ClearBroker() {
        PrepareBuilder();
        result.hasBroker = false;
        result.broker_ = "";
        return this;
      }
      
      public bool HasExchange {
        get { return result.hasExchange; }
      }
      public string Exchange {
        get { return result.Exchange; }
        set { SetExchange(value); }
      }
      public Builder SetExchange(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasExchange = true;
        result.exchange_ = value;
        return this;
      }
      public Builder ClearExchange() {
        PrepareBuilder();
        result.hasExchange = false;
        result.exchange_ = "";
        return this;
      }
      
      public bool HasInvestor {
        get { return result.hasInvestor; }
      }
      public string Investor {
        get { return result.Investor; }
        set { SetInvestor(value); }
      }
      public Builder SetInvestor(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasInvestor = true;
        result.investor_ = value;
        return this;
      }
      public Builder ClearInvestor() {
        PrepareBuilder();
        result.hasInvestor = false;
        result.investor_ = "";
        return this;
      }
      
      public bool HasInstrument {
        get { return result.hasInstrument; }
      }
      public string Instrument {
        get { return result.Instrument; }
        set { SetInstrument(value); }
      }
      public Builder SetInstrument(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasInstrument = true;
        result.instrument_ = value;
        return this;
      }
      public Builder ClearInstrument() {
        PrepareBuilder();
        result.hasInstrument = false;
        result.instrument_ = "";
        return this;
      }
      
      public bool HasLimitPrice {
        get { return result.hasLimitPrice; }
      }
      public double LimitPrice {
        get { return result.LimitPrice; }
        set { SetLimitPrice(value); }
      }
      public Builder SetLimitPrice(double value) {
        PrepareBuilder();
        result.hasLimitPrice = true;
        result.limitPrice_ = value;
        return this;
      }
      public Builder ClearLimitPrice() {
        PrepareBuilder();
        result.hasLimitPrice = false;
        result.limitPrice_ = 0D;
        return this;
      }
      
      public bool HasStopPrice {
        get { return result.hasStopPrice; }
      }
      public double StopPrice {
        get { return result.StopPrice; }
        set { SetStopPrice(value); }
      }
      public Builder SetStopPrice(double value) {
        PrepareBuilder();
        result.hasStopPrice = true;
        result.stopPrice_ = value;
        return this;
      }
      public Builder ClearStopPrice() {
        PrepareBuilder();
        result.hasStopPrice = false;
        result.stopPrice_ = 0D;
        return this;
      }
      
      public bool HasVolume {
        get { return result.hasVolume; }
      }
      public long Volume {
        get { return result.Volume; }
        set { SetVolume(value); }
      }
      public Builder SetVolume(long value) {
        PrepareBuilder();
        result.hasVolume = true;
        result.volume_ = value;
        return this;
      }
      public Builder ClearVolume() {
        PrepareBuilder();
        result.hasVolume = false;
        result.volume_ = 0L;
        return this;
      }
      
      public bool HasDirection {
       get { return result.hasDirection; }
      }
      public global::Tdx.Order.Types.Direction Direction {
        get { return result.Direction; }
        set { SetDirection(value); }
      }
      public Builder SetDirection(global::Tdx.Order.Types.Direction value) {
        PrepareBuilder();
        result.hasDirection = true;
        result.direction_ = value;
        return this;
      }
      public Builder ClearDirection() {
        PrepareBuilder();
        result.hasDirection = false;
        result.direction_ = global::Tdx.Order.Types.Direction.BUY;
        return this;
      }
      
      public bool HasDatetime {
        get { return result.hasDatetime; }
      }
      public long Datetime {
        get { return result.Datetime; }
        set { SetDatetime(value); }
      }
      public Builder SetDatetime(long value) {
        PrepareBuilder();
        result.hasDatetime = true;
        result.datetime_ = value;
        return this;
      }
      public Builder ClearDatetime() {
        PrepareBuilder();
        result.hasDatetime = false;
        result.datetime_ = 0L;
        return this;
      }
      
      public bool HasType {
       get { return result.hasType; }
      }
      public global::Tdx.Order.Types.Type Type {
        get { return result.Type; }
        set { SetType(value); }
      }
      public Builder SetType(global::Tdx.Order.Types.Type value) {
        PrepareBuilder();
        result.hasType = true;
        result.type_ = value;
        return this;
      }
      public Builder ClearType() {
        PrepareBuilder();
        result.hasType = false;
        result.type_ = global::Tdx.Order.Types.Type.MARKET;
        return this;
      }
      
      public bool HasCurrency {
        get { return result.hasCurrency; }
      }
      public string Currency {
        get { return result.Currency; }
        set { SetCurrency(value); }
      }
      public Builder SetCurrency(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasCurrency = true;
        result.currency_ = value;
        return this;
      }
      public Builder ClearCurrency() {
        PrepareBuilder();
        result.hasCurrency = false;
        result.currency_ = "";
        return this;
      }
      
      public bool HasExpiry {
        get { return result.hasExpiry; }
      }
      public string Expiry {
        get { return result.Expiry; }
        set { SetExpiry(value); }
      }
      public Builder SetExpiry(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasExpiry = true;
        result.expiry_ = value;
        return this;
      }
      public Builder ClearExpiry() {
        PrepareBuilder();
        result.hasExpiry = false;
        result.expiry_ = "";
        return this;
      }
      
      public bool HasSecurityType {
        get { return result.hasSecurityType; }
      }
      public string SecurityType {
        get { return result.SecurityType; }
        set { SetSecurityType(value); }
      }
      public Builder SetSecurityType(string value) {
        pb::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasSecurityType = true;
        result.securityType_ = value;
        return this;
      }
      public Builder ClearSecurityType() {
        PrepareBuilder();
        result.hasSecurityType = false;
        result.securityType_ = "";
        return this;
      }
    }
    static Order() {
      object.ReferenceEquals(global::Tdx.Proto.Order.Descriptor, null);
    }
  }
  
  #endregion
  
}

#endregion Designer generated code
